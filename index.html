<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Assistente alla privacy per il sistema sanitario italiano</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:#0b0c10; color:#fff;
    }

    /* Layout a griglia: header, (video+stato), chat (1fr), log, input */
    .wrap {
      height: 100%;
      max-width: 980px;
      margin: 0 auto;
      padding: 16px;
      display: grid;
      grid-template-rows: auto auto 1fr auto auto;
      gap: 12px;
      box-sizing: border-box;
    }

    h1 { margin:0; font-size: clamp(20px,4vw,32px); text-align:center; }
    video { width:100%; background:#000; border-radius:12px; display:block; }
    .status { color:#9aa0a6; font-size:14px; text-align:center; }

    /* CHAT: sola sezione scrollabile, ancorata in basso */
    .chat {
      min-height: 0;               /* necessario in grid per far funzionare l'overflow */
      height: 100%;
      overflow-y: auto;            /* scorre solo qui */
      display: flex;
      flex-direction: column;
      justify-content: flex-end;   /* ultimi messaggi in basso */
      text-align: left;
      padding: 10px;
      gap: 8px;
      border: 1px solid #15181d;
      border-radius: 12px;
      background: #0f1115;
      box-sizing: border-box;

      /* Scrollbar nativa personalizzata */
      scrollbar-width: thin;
      scrollbar-color: #2b98f0 #0b0c10;
    }
    .chat::-webkit-scrollbar { width: 10px; }
    .chat::-webkit-scrollbar-track { background: #0b0c10; border-radius: 999px; }
    .chat::-webkit-scrollbar-thumb {
      background: #2b98f0; border-radius: 999px; border: 2px solid #0f1115;
    }
    @supports (scrollbar-gutter: stable) { .chat { scrollbar-gutter: stable; } }

    .msg {
      display: inline-flex;
      max-width: 85%;
      padding: 10px 12px;
      border-radius: 12px;
      white-space: pre-wrap;
      line-height: 1.35;
      word-wrap: break-word;
      box-sizing: border-box;
    }
    .msg.user {
      align-self: flex-end;
      background: #1a73e8;
      color: #fff;
      border-bottom-right-radius: 6px;
    }
    .msg.assistant {
      align-self: flex-start;
      background: #0b0c10;
      color: #e3e3e3;
      border: 1px solid #15181d;
      border-bottom-left-radius: 6px;
    }

    .log { font-size:14px; color:#9aa0a6; min-height:18px; text-align:left; }

    /* Riga input: resta fissa sotto la chat */
    .row { display:flex; gap:8px; }
    input {
      flex:1; padding:12px; border-radius:10px; border:0;
      background:#0f1115; color:#fff;
    }
    button {
      padding:12px 16px; border-radius:10px; border:0;
      background:#5ac8fa; color:#001018; font-weight:600; cursor:pointer;
    }
    button[disabled] { opacity:0.6; cursor:not-allowed; }

    @media (max-width: 640px) {
      .row { gap:6px; }
      button { width: 30%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Assistente AI</h1>

    <!-- Video avatar (nascosto finché non c’è token HeyGen) + stato -->
    <video id="avatarVideo" autoplay playsinline muted style="display:none"></video>
    <div id="status" class="status">Modalità chat testuale (avatar non ancora configurato).</div>

    <!-- CHAT: unica area scrollabile della pagina -->
    <div id="chat" class="chat" aria-live="polite" aria-label="Conversazione"></div>

    <!-- Stato/diagnostica -->
    <div id="log" class="log"></div>

    <!-- INPUT: fisso sotto la chat -->
    <div class="row">
      <input id="q" placeholder="Scrivi qui la tua domanda in italiano…" autocomplete="off" />
      <button id="ask">Invia</button>
    </div>
  </div>

  <script type="module">
    const API_BASE = ''; // percorsi relativi

    const $ = id => document.getElementById(id);
    const statusEl = $("status"), logEl = $("log"), videoEl = $("avatarVideo");
    const askBtn = $("ask"), qEl = $("q"), chatEl = $("chat");
    const history = [];

    // Avatar opzionale (si attiverà con HEYGEN_API_KEY su Vercel)
    const MAX_SESSION_MS = 9 * 60 * 1000;
    let StreamingAvatar, StreamingEvents, avatar = null, startedAt = 0, rotateTimer;

    async function loadSDK() {
      ({ default: StreamingAvatar, StreamingEvents } =
        await import("https://unpkg.com/@heygen/streaming-avatar/dist/index.js"));
    }

    async function initAvatarIfAvailable() {
      try {
        const r = await fetch(`${API_BASE}/api/get-heygen-token`, { method: "POST" });
        const j = await r.json();
        if (!r.ok || !j?.token) throw new Error("no_token");

        await loadSDK();
        avatar = new StreamingAvatar({ token: j.token });

        avatar.on(StreamingEvents.STREAM_READY, (e) => {
          videoEl.srcObject = e.detail;
          videoEl.style.display = "block";
          videoEl.addEventListener('click', () => { videoEl.muted = false; }, { once:true });
          videoEl.play();
          statusEl.textContent = "Avatar pronto. Fai una domanda.";
          startedAt = Date.now();
          rotateTimer && clearInterval(rotateTimer);
          rotateTimer = setInterval(rotateIfNeeded, 10000);
        });
        avatar.on(StreamingEvents.STREAM_DISCONNECTED, restartAvatar);
        avatar.on(StreamingEvents.ERROR, restartAvatar);

        await avatar.createStartAvatar({ quality: "high" });
      } catch {
        videoEl.style.display = "none";
        statusEl.textContent = "Modalità chat testuale (avatar non ancora configurato).";
      }
    }

    async function rotateIfNeeded() {
      if (!avatar) return;
      if (Date.now() - startedAt < MAX_SESSION_MS) return;
      await restartAvatar();
    }
    async function restartAvatar() {
      try { if (avatar?.stopAvatar) await avatar.stopAvatar(); if (avatar?.stop) await avatar.stop(); } catch {}
      await initAvatarIfAvailable();
    }

    // --- CHAT UI ---
    function addMessage(role, text) {
      const el = document.createElement("div");
      el.className = `msg ${role}`;
      el.textContent = text;
      chatEl.appendChild(el);
      chatEl.scrollTop = chatEl.scrollHeight; // resta ancorata in basso
    }

    async function sendMessage() {
      const msg = qEl.value.trim();
      if (!msg) return;

      qEl.value = "";
      askBtn.disabled = true;
      askBtn.textContent = "Invio…";
      logEl.textContent = "Chiedo al modello…";

      history.push({ role: "user", content: msg });
      addMessage("user", msg);

      try {
        const r = await fetch(`${API_BASE}/api/chat`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: msg, history: history.slice(-6) })
        });

        if (!r.ok) {
          const t = await r.text().catch(()=>"(no body)");
          logEl.textContent = `Errore API: ${r.status} ${t}`;
          return;
        }

        const { answer } = await r.json();
        history.push({ role: "assistant", content: answer });
        addMessage("assistant", answer);
        logEl.textContent = "";

        if (avatar) { try { await avatar.speak({ text: answer }); } catch {} }
      } catch (e) {
        logEl.textContent = `Errore di rete: ${e?.message || e}`;
      } finally {
        askBtn.disabled = false;
        askBtn.textContent = "Invia";
      }
    }

    askBtn.addEventListener("click", sendMessage);
    qEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendMessage();
      }
    });
    qEl.setAttribute("enterkeyhint", "send");
    qEl.setAttribute("autocomplete", "off");

    // Ping diagnostico: GET /api/chat deve dare 405
    (async () => {
      try {
        const ping = await fetch(`${API_BASE}/api/chat`, { method: "GET" });
        if (ping.status !== 405) console.warn("Ping /api/chat atteso 405, ottenuto:", ping.status);
      } catch (e) {
        statusEl.textContent = "Errore di rete verso l'API. Ricarica la pagina su questo dominio.";
      }
    })();

    // Avvio
    initAvatarIfAvailable();
  </script>
</body>
</html>
